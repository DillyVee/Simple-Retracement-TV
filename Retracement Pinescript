// @version=5
strategy("Retracement Trader - ATH/ATL Multi-Timeframe",
  shorttitle="Retrace-MTF",
  overlay=true,
  initial_capital=100000,
  default_qty_type=strategy.percent_of_equity,
  default_qty_value=100,
  commission_type=strategy.commission.percent,
  commission_value=0.075,
  slippage=1)

// ============================================================================
// MULTI-TIMEFRAME RETRACEMENT TRADING SYSTEM
// ============================================================================
// Features:
// - Fetch ATH/ATL from higher timeframes (bypass data restrictions)
// - Retracement calculated as % DOWN from ATH (not % of range)
// - Multiple customizable entry levels (% below ATH) with individual toggles
// - Multiple customizable exit levels (% below ATH) with individual toggles
// - Entry when bar closes at/below retracement level (% down from ATH)
// - Exit when price returns to stored ATH (TP) OR closes below exit level (SL)
// - Each retracement level can only be used ONCE per new all-time high
// - Level usage resets when a new ATH is reached
// - Two range modes: ATL-ATH or 0-ATH (for display only)
// - Visual level display on chart with color coding
// - Entry tracking and alerts
//
// ✅ STRICT NON-REPAINTING MODE – KEY FEATURES
//
// HTF Levels Only Update on Close
// - ATH and ATL are only updated when the higher timeframe candle closes
// - Eliminates false breakouts caused by intrabar wicks
//
// Entry Levels Trigger on Confirmed Crosses
// - Long entries fire only after the candle closes below the retracement level
// - Prevents signals that vanish or shift later
//
// SL/TP Execution Is Reliable
// - Stop-loss levels and take-profit targets are never triggered mid-bar
// - Trades exit exactly where backtests show, matching live fills
//
// Alerts Trigger on Non-Repainting Signals
// - Alerts fire after a valid bar close triggers a trade
// - Historical signals will not change retroactively
//
// Retracement Level Usage Reset
// - Levels used for an ATH reset only on a new confirmed ATH
// - Prevents multiple entries at the same level for the same ATH
//
// Backtests = Reality
// - Every historical trade in the strategy now matches what would have happened live
// - Equity curve is realistic, PnL is reliable
// ============================================================================

// ============================================================================
// USER INPUTS
// ============================================================================

// Timeframe for ATH/ATL calculation
htf_input = input.timeframe("D", "ATH/ATL Timeframe",
  group="Multi-Timeframe Settings",
  tooltip="Fetch ATH/ATL from this timeframe to get true all-time levels. Use D (daily) or W (weekly) for complete history.")

// Range Selection
range_mode = input.string("ATL to ATH", "Range Mode",
  options=["ATL to ATH", "0 to ATH"],
  group="Range Settings",
  tooltip="ATL to ATH uses all-time low to all-time high. 0 to ATH uses zero to all-time high.")

// ============================================================================
// LONG ENTRY LEVELS (% retracement down from ATH)
// Example: 12.5% means enter when price is 12.5% below ATH (ATH * 0.875)
// ============================================================================
enable_long_entry_1 = input.bool(true, "Entry 1", inline="le1", group="Long Entry Levels")
long_entry_pct_1 = input.float(11.4, "", minval=0, maxval=100, step=0.1, inline="le1", group="Long Entry Levels")

enable_long_entry_2 = input.bool(true, "Entry 2", inline="le2", group="Long Entry Levels")
long_entry_pct_2 = input.float(21.4, "", minval=0, maxval=100, step=0.1, inline="le2", group="Long Entry Levels")

enable_long_entry_3 = input.bool(true, "Entry 3", inline="le3", group="Long Entry Levels")
long_entry_pct_3 = input.float(33.3, "", minval=0, maxval=100, step=0.1, inline="le3", group="Long Entry Levels")

enable_long_entry_4 = input.bool(true, "Entry 4", inline="le4", group="Long Entry Levels")
long_entry_pct_4 = input.float(61.8, "", minval=0, maxval=100, step=0.1, inline="le4", group="Long Entry Levels")

enable_long_entry_5 = input.bool(true, "Entry 5", inline="le5", group="Long Entry Levels")
long_entry_pct_5 = input.float(75, "", minval=0, maxval=100, step=0.1, inline="le5", group="Long Entry Levels")

enable_long_entry_6 = input.bool(true, "Entry 6", inline="le6", group="Long Entry Levels")
long_entry_pct_6 = input.float(87.5, "", minval=0, maxval=100, step=0.1, inline="le6", group="Long Entry Levels")

// ============================================================================
// LONG EXIT LEVELS (% retracement down from ATH - Stop-loss levels)
// Example: 11.4% means exit if price drops to 11.4% below ATH (ATH * 0.886)
// ============================================================================
enable_long_exit_1 = input.bool(true, "Exit 1", inline="lx1", group="Long Exit Levels")
long_exit_pct_1 = input.float(12.5, "", minval=0, maxval=100, step=0.1, inline="lx1", group="Long Exit Levels")

enable_long_exit_2 = input.bool(true, "Exit 2", inline="lx2", group="Long Exit Levels")
long_exit_pct_2 = input.float(25, "", minval=0, maxval=100, step=0.1, inline="lx2", group="Long Exit Levels")

enable_long_exit_3 = input.bool(true, "Exit 3", inline="lx3", group="Long Exit Levels")
long_exit_pct_3 = input.float(38.2, "", minval=0, maxval=100, step=0.1, inline="lx3", group="Long Exit Levels")

enable_long_exit_4 = input.bool(true, "Exit 4", inline="lx4", group="Long Exit Levels")
long_exit_pct_4 = input.float(66.6, "", minval=0, maxval=100, step=0.1, inline="lx4", group="Long Exit Levels")

enable_long_exit_5 = input.bool(true, "Exit 5", inline="lx5", group="Long Exit Levels")
long_exit_pct_5 = input.float(78.6, "", minval=0, maxval=100, step=0.1, inline="lx5", group="Long Exit Levels")

enable_long_exit_6 = input.bool(true, "Exit 6", inline="lx6", group="Long Exit Levels")
long_exit_pct_6 = input.float(88.6, "", minval=0, maxval=100, step=0.1, inline="lx6", group="Long Exit Levels")

// Additional Levels to Display
show_23_6 = input.bool(true, "Show 23.6%", group="Display Levels")
show_38_2 = input.bool(true, "Show 38.2%", group="Display Levels")
show_50_0 = input.bool(true, "Show 50.0%", group="Display Levels")
show_61_8 = input.bool(true, "Show 61.8%", group="Display Levels")
show_78_6 = input.bool(true, "Show 78.6%", group="Display Levels")

// Trading Mode
trading_mode = input.string("Both", "Trading Mode",
  options=["Long Only", "Short Only", "Both"],
  group="Trading Settings")

// Entry Delay
entry_delay = input.int(0, "Bars Delay After Reference High", minval=0, maxval=500,
  group="Trading Settings",
  tooltip="Wait this many bars after reference high is set before allowing entries. Prevents entering too early. 0 = no delay.")

// Post-Crash Retracement Mode
use_post_crash_mode = input.bool(false, "Post-Crash Retracement Mode", group="Post-Crash Mode Settings",
  tooltip="SWITCHES MODE: When ON, trade retracements from post-crash highs instead of ATHs. Detects crashes, waits for stabilization, then trades retracements from recovery highs. Levels reset on new crashes (not ATHs).")
use_zscore = input.bool(true, "Use Z-Score Detection", group="Post-Crash Mode Settings",
  tooltip="Use statistical z-score instead of fixed % threshold. More adaptive to market volatility.")
zscore_threshold = input.float(2.5, "Z-Score Threshold", minval=1.0, maxval=5.0, step=0.1, group="Post-Crash Mode Settings",
  tooltip="Z-score threshold for crash detection (e.g., 2.5 = drawdown is 2.5 std devs above mean). Higher = only detect more extreme crashes.")
crash_drop_pct = input.float(30.0, "Fixed Drop Threshold (%)", minval=10, maxval=90, step=1, group="Post-Crash Mode Settings",
  tooltip="Fixed % drop threshold for crash detection (used when z-score disabled)")
crash_lookback = input.int(100, "Lookback Period (bars)", minval=20, maxval=500, group="Post-Crash Mode Settings",
  tooltip="Period to calculate statistics and detect crashes")
stabilization_days = input.int(30, "Stabilization Days After Low", minval=0, maxval=365, group="Post-Crash Mode Settings",
  tooltip="Wait this many days after crash low before tracking recovery high. Price must not make new lows during this period.")
min_bars_after_crash = input.int(3, "Min Bars After Crash (Fast Entry)", minval=0, maxval=100, group="Post-Crash Mode Settings",
  tooltip="Allow entries this many bars after crash detection, even if stabilization isn't complete. 0 = require full stabilization. Use for faster entries.")

// Slope/Gradient Change Detection (Quant-Fund Methods)
use_slope_detection = input.bool(true, "Enable Slope Change Detection", group="Slope Detection Settings",
  tooltip="Use mathematical slope change detection to identify local highs/lows instead of fixed levels. Based on methods used by Two Sigma, Citadel, DE Shaw.")
slope_method = input.string("Linear Regression", "Slope Method",
  options=["Linear Regression", "EMA Slope", "Savitzky-Golay (Approx)"],
  group="Slope Detection Settings",
  tooltip="Linear Regression: Rolling regression slope | EMA Slope: Rate of change of EMA | Savitzky-Golay: Polynomial smoothing (approximated)")
slope_period = input.int(14, "Slope Calculation Period", minval=3, maxval=100, group="Slope Detection Settings",
  tooltip="Lookback period for slope calculation. Smaller = more sensitive to price changes. Larger = smoother, less noise.")
slope_smoothing = input.int(3, "Slope Smoothing Period", minval=1, maxval=50, group="Slope Detection Settings",
  tooltip="Additional smoothing applied to slope values to reduce false signals. 1 = no smoothing.")
min_slope_threshold = input.float(0.0001, "Min Slope Threshold", minval=0.0, step=0.0001, group="Slope Detection Settings",
  tooltip="Minimum absolute slope value to consider as a valid trend. Filters out flat/noisy periods. Set to 0 to disable.")
confirm_bars = input.int(2, "Confirmation Bars", minval=1, maxval=10, group="Slope Detection Settings",
  tooltip="Number of bars the slope must maintain new direction before confirming high/low. Reduces false signals.")

// Position Sizing
base_position_size = input.float(100.0, "Position Size (% of equity)", minval=1, maxval=100, group="Trading Settings")

// Display
show_levels = input.bool(true, "Show Retracement Levels", group="Display")
show_info = input.bool(true, "Show Info Table", group="Display")
label_offset = input.int(20, "Label Offset (bars)", minval=1, group="Display")

// ============================================================================
// FETCH HIGH/LOW FROM HIGHER TIMEFRAME
// ============================================================================

// Determine effective timeframe (use current if higher timeframe is lower than current)
effective_htf = timeframe.in_seconds(htf_input) >= timeframe.in_seconds(timeframe.period) ? htf_input : timeframe.period

// Request high/low from higher timeframe - NON-REPAINTING MODE
// lookahead_off ensures HTF data only updates on confirmed HTF bar close
[htf_high, htf_low] = request.security(syminfo.tickerid, effective_htf, [high, low], lookahead=barmerge.lookahead_off)

// ============================================================================
// SLOPE/GRADIENT CALCULATION FUNCTIONS (QUANT-FUND METHODS)
// ============================================================================

// Function: Linear Regression Slope
// Calculates the slope of a linear regression over the lookback period
// This is the most mathematically rigorous method used by quant funds
linreg_slope(src, length) =>
    // Linear regression uses least squares to fit: y = mx + b
    // We calculate the slope (m) using the formula:
    // m = (n*Σxy - Σx*Σy) / (n*Σx² - (Σx)²)

    sum_x = 0.0
    sum_y = 0.0
    sum_xy = 0.0
    sum_x2 = 0.0

    for i = 0 to length - 1
        x = float(i)
        y = src[length - 1 - i]
        sum_x := sum_x + x
        sum_y := sum_y + y
        sum_xy := sum_xy + x * y
        sum_x2 := sum_x2 + x * x

    n = float(length)
    slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)
    slope

// Function: EMA Slope (Rate of Change)
// Calculates the rate of change of an EMA
// Simpler and faster, adapts well to volatility
ema_slope(src, length) =>
    ema_val = ta.ema(src, length)
    slope = ema_val - ema_val[1]
    slope

// Function: Savitzky-Golay Approximation
// Uses weighted moving average to approximate polynomial smoothing
// Pine Script doesn't have native SG filter, so we use weighted MA as approximation
savgol_slope(src, length) =>
    // Use triangular weights (approximates 2nd order polynomial)
    // Weights are symmetric and favor center points
    sum_weighted = 0.0
    sum_weights = 0.0

    for i = 0 to length - 1
        // Triangular weight: higher in the middle, lower at edges
        weight = length - math.abs(i - length / 2)
        sum_weighted := sum_weighted + src[i] * weight
        sum_weights := sum_weights + weight

    smoothed = sum_weighted / sum_weights
    slope = smoothed - smoothed[1]
    slope

// Calculate slope based on selected method
calculate_slope(src) =>
    raw_slope = switch slope_method
        "Linear Regression" => linreg_slope(src, slope_period)
        "EMA Slope" => ema_slope(src, slope_period)
        "Savitzky-Golay (Approx)" => savgol_slope(src, slope_period)
        => 0.0

    // Apply smoothing to reduce noise
    smoothed_slope = slope_smoothing > 1 ? ta.sma(raw_slope, slope_smoothing) : raw_slope
    smoothed_slope

// ============================================================================
// SLOPE CHANGE DETECTION - IDENTIFY LOCAL HIGHS AND LOWS
// ============================================================================

// Calculate slope for HTF close price
price_slope = calculate_slope(close)

// Normalize slope by price to make it scale-independent
// This ensures threshold works across different price ranges
normalized_slope = close > 0 ? price_slope / close : 0.0

// Apply minimum threshold to filter noise
significant_slope = math.abs(normalized_slope) >= min_slope_threshold ? normalized_slope : 0.0

// Detect slope sign (direction)
// 1 = positive (uptrend), -1 = negative (downtrend), 0 = flat
var int slope_sign = 0
var int prev_slope_sign = 0
var int confirm_count = 0

current_sign = significant_slope > 0 ? 1 : (significant_slope < 0 ? -1 : 0)

// Confirmation logic: require slope to maintain direction for confirm_bars
if current_sign != slope_sign
    if current_sign == prev_slope_sign
        confirm_count := confirm_count + 1
    else
        confirm_count := 1
        prev_slope_sign := current_sign

    if confirm_count >= confirm_bars
        slope_sign := current_sign
        confirm_count := 0
else
    confirm_count := 0

// Detect slope changes (extrema detection)
// slope_change_to_positive: slope changed from negative to positive → LOCAL MINIMUM
// slope_change_to_negative: slope changed from positive to negative → LOCAL MAXIMUM
slope_change_to_positive = slope_sign == 1 and slope_sign[1] == -1
slope_change_to_negative = slope_sign == -1 and slope_sign[1] == 1

// Track slope-detected highs and lows
var float slope_detected_high = na
var int slope_high_bar = 0
var float slope_detected_low = na
var int slope_low_bar = 0

// When slope changes to negative, we've detected a local maximum
// Mark the high from the bars before the change (during the uptrend)
if use_slope_detection and slope_change_to_negative
    // Look back over the last slope_period bars to find the actual high
    lookback_high = ta.highest(high, slope_period)
    slope_detected_high := lookback_high
    slope_high_bar := bar_index

// When slope changes to positive, we've detected a local minimum
// Mark the low from the bars before the change (during the downtrend)
if use_slope_detection and slope_change_to_positive
    // Look back over the last slope_period bars to find the actual low
    lookback_low = ta.lowest(low, slope_period)
    slope_detected_low := lookback_low
    slope_low_bar := bar_index

// ============================================================================
// CALCULATE ALL-TIME HIGH AND LOW FROM HTF DATA
// ============================================================================

var float ath = na
var float atl = na
var int ath_bar = 0
var int atl_bar = 0
var int last_ath_bar = 0  // Track when ATH was last updated for entry delay

// Initialize on first bar
if na(ath) or na(atl)
    ath := htf_high
    atl := htf_low
    ath_bar := bar_index
    atl_bar := bar_index
    last_ath_bar := bar_index

// Update all-time high from HTF data
if htf_high > ath
    ath := htf_high
    ath_bar := bar_index
    last_ath_bar := bar_index  // Update the last ATH bar for delay tracking

// Update all-time low from HTF data
if htf_low < atl
    atl := htf_low
    atl_bar := bar_index

// Store the ATH for exits (this is our take profit target for longs)
var float stored_ath_for_exit = na
stored_ath_for_exit := ath  // Always track current ATH

// Store the ATL for exits (this is our take profit target for shorts)
var float stored_atl_for_exit = na
stored_atl_for_exit := atl  // Always track current ATL

// ============================================================================
// POST-CRASH RETRACEMENT MODE
// ============================================================================

var float crash_low = na  // The low from the crash
var int crash_low_bar = 0  // Bar when crash low was detected
var bool crash_detected = false  // Has crash been detected
var bool stabilization_complete = false  // Has stabilization period passed
var float lookback_high = na  // High from lookback period for drop calculation
var float current_zscore = 0.0  // Current z-score of the drop
var float post_crash_high = na  // Highest high since stabilization complete
var int post_crash_high_bar = 0  // Bar when post-crash high was set

// --------- ROBUST CRASH DETECTION WITH DRAWDOWN-BASED Z-SCORE ------------
// FIXED: Now properly compares drawdowns using consistent measurement periods

// Calculate current drawdown from lookback high
lookback_high := ta.highest(htf_high, crash_lookback)
current_drop_pct = lookback_high > 0 ? 100.0 * (lookback_high - htf_low) / lookback_high : 0.0

// Z-Score calculation: compare current drawdown to historical drawdowns
// Strategy: Build a time series of max drawdowns, each measured over crash_lookback bars
// Then calculate z-score of current drawdown vs historical distribution
var float mean_drawdown = 0.0
var float stdev_drawdown = 0.0

if use_zscore
    // Calculate statistics of the drawdown series over crash_lookback period
    // current_drop_pct is calculated the same way on each bar, creating a time series
    // of max drawdowns that we can use for statistical analysis
    mean_drawdown := ta.sma(current_drop_pct, crash_lookback)
    stdev_drawdown := ta.stdev(current_drop_pct, crash_lookback)

    // Z-score: how many std devs is current drawdown above the mean?
    // Higher drawdown = higher z-score (positive value)
    current_zscore := (stdev_drawdown > 0.1) ? (current_drop_pct - mean_drawdown) / stdev_drawdown : 0.0
else
    current_zscore := 0.0

// Crash detection
var bool is_crash = false
if use_zscore
    // Crash if z-score >= threshold (large positive z-score = abnormally large drawdown)
    // User sets threshold like 2.5 = "2.5 std devs above mean drawdown"
    is_crash := current_zscore >= math.abs(zscore_threshold)
else
    // Use fixed percentage threshold
    is_crash := current_drop_pct >= crash_drop_pct

// Track when crash condition is first met
if use_post_crash_mode and is_crash and not crash_detected
    crash_detected := true
    crash_low := htf_low
    crash_low_bar := bar_index
    stabilization_complete := false
    post_crash_high := na  // Reset post-crash high

    // Label the crash low with z-score
    label.new(bar_index, htf_low,
      "CRASH LOW\nz=" + str.tostring(current_zscore, "#.##"),
      style=label.style_label_up, color=color.new(color.red, 0), textcolor=color.white, size=size.small)

// Check if price makes a new low during stabilization period (resets timer)
if crash_detected and not stabilization_complete
    if htf_low < crash_low
        crash_low := htf_low
        crash_low_bar := bar_index  // Reset the timer

// Calculate bars since crash low
bars_since_crash_low = crash_detected ? bar_index - crash_low_bar : 0

// Convert stabilization days to bars based on timeframe (robust calculation)
bars_per_day = timeframe.in_seconds("D") / timeframe.in_seconds(effective_htf)
stabilization_bars = math.max(1, math.round(stabilization_days * bars_per_day))  // Ensure at least 1 bar

// Check if stabilization period is complete
if crash_detected and bars_since_crash_low >= stabilization_bars
    stabilization_complete := true

// Track highest high since stabilization complete (this becomes our reference high in post-crash mode)
if use_post_crash_mode and stabilization_complete
    // Initialize post_crash_high immediately when stabilization completes
    // Use highest HTF high since crash low bar to give an immediate reference
    if na(post_crash_high)
        lookback_len = math.max(1, bar_index - crash_low_bar + 1)
        post_crash_high := ta.highest(htf_high, lookback_len)
        post_crash_high_bar := bar_index
    // Update with new highs after initialization
    if htf_high > post_crash_high
        post_crash_high := htf_high
        post_crash_high_bar := bar_index

// ============================================================================
// DETERMINE REFERENCE HIGH (Slope-Detected, ATH, or Post-Crash High)
// ============================================================================

// Priority order:
// 1. If Slope Detection enabled: use slope-detected high
// 2. If Post-Crash Mode enabled: use post-crash high
// 3. Otherwise: use ATH
var float reference_high = na
var int reference_high_bar = 0
var string reference_source = "ATH"  // Track what source is being used

if use_slope_detection
    // Slope Detection Mode: use slope-detected high
    if not na(slope_detected_high)
        reference_high := slope_detected_high
        reference_high_bar := slope_high_bar
        reference_source := "Slope High"
    else
        // Fallback to ATH if no slope high detected yet
        reference_high := ath
        reference_high_bar := last_ath_bar
        reference_source := "ATH (fallback)"
else if use_post_crash_mode
    // Post-Crash Mode: prefer post-crash high, but fallback to ATH if not available yet
    // This prevents blocking all trades while waiting for crash detection + stabilization
    if not na(post_crash_high)
        reference_high := post_crash_high
        reference_high_bar := post_crash_high_bar
        reference_source := "Post-Crash High"
    else
        // Fallback to ATH while post-crash high not set (allows entries to happen)
        reference_high := ath
        reference_high_bar := last_ath_bar
        reference_source := "ATH (fallback)"
else
    // Normal ATH Mode: always use ATH
    reference_high := ath
    reference_high_bar := last_ath_bar
    reference_source := "ATH"

// ============================================================================
// CALCULATE RETRACEMENT LEVELS (% down from Reference High)
// ============================================================================

// Determine range based on mode (for display only)
range_low = range_mode == "ATL to ATH" ? atl : 0.0
range_high = ath
range_size = range_high - range_low

// Calculate retracement level prices as % down from reference high
// Entry at 12.5% means price is 12.5% below reference high (ref_high * 0.875)
calc_retracement(percentage) =>
    reference_high * (1 - percentage / 100.0)

// Long Entry Levels - Calculate as % down from current ATH
long_entry_price_1 = enable_long_entry_1 ? calc_retracement(long_entry_pct_1) : na
long_entry_price_2 = enable_long_entry_2 ? calc_retracement(long_entry_pct_2) : na
long_entry_price_3 = enable_long_entry_3 ? calc_retracement(long_entry_pct_3) : na
long_entry_price_4 = enable_long_entry_4 ? calc_retracement(long_entry_pct_4) : na
long_entry_price_5 = enable_long_entry_5 ? calc_retracement(long_entry_pct_5) : na
long_entry_price_6 = enable_long_entry_6 ? calc_retracement(long_entry_pct_6) : na

// Long Exit Levels - Calculate as % down from current ATH
long_exit_price_1 = enable_long_exit_1 ? calc_retracement(long_exit_pct_1) : na
long_exit_price_2 = enable_long_exit_2 ? calc_retracement(long_exit_pct_2) : na
long_exit_price_3 = enable_long_exit_3 ? calc_retracement(long_exit_pct_3) : na
long_exit_price_4 = enable_long_exit_4 ? calc_retracement(long_exit_pct_4) : na
long_exit_price_5 = enable_long_exit_5 ? calc_retracement(long_exit_pct_5) : na
long_exit_price_6 = enable_long_exit_6 ? calc_retracement(long_exit_pct_6) : na

// Common Fibonacci levels (for reference display only) - as % down from ATH
level_23_6 = calc_retracement(23.6)
level_38_2 = calc_retracement(38.2)
level_50_0 = calc_retracement(50.0)
level_61_8 = calc_retracement(61.8)
level_78_6 = calc_retracement(78.6)

// Store the ATH at entry for take profit target
var float entry_ath = na

// Track which entry level was used (for tied exit levels)
var int entry_level_used = 0  // 0 = no position, 1-6 = entry level number

// ============================================================================
// TRACK RETRACEMENT LEVEL USAGE
// ============================================================================

// Track which levels have been used for the current reference high
var bool used_entry_1 = false
var bool used_entry_2 = false
var bool used_entry_3 = false
var bool used_entry_4 = false
var bool used_entry_5 = false
var bool used_entry_6 = false

// Track previous reference values to detect resets
var float prev_ath = na
var float prev_post_crash_high = na
var float prev_slope_high = na

// Initialize tracking
if na(prev_ath)
    prev_ath := ath

// Reset logic depends on mode
if use_slope_detection
    // Slope Detection Mode: reset when a new slope high is detected
    if not na(slope_detected_high)
        if na(prev_slope_high)
            prev_slope_high := slope_detected_high

        // Reset when we detect a new slope high (slope change to negative)
        if slope_change_to_negative
            // New slope high detected - reset all used flags
            used_entry_1 := false
            used_entry_2 := false
            used_entry_3 := false
            used_entry_4 := false
            used_entry_5 := false
            used_entry_6 := false
            prev_slope_high := slope_detected_high
else if use_post_crash_mode
    // Post-Crash Mode: reset when post_crash_high INCREASES (new recovery high)
    // This allows cycling through levels multiple times as price makes new highs after crash
    if not na(post_crash_high)
        if na(prev_post_crash_high)
            prev_post_crash_high := post_crash_high

        if post_crash_high > prev_post_crash_high
            // New post-crash high reached - reset all used flags
            used_entry_1 := false
            used_entry_2 := false
            used_entry_3 := false
            used_entry_4 := false
            used_entry_5 := false
            used_entry_6 := false
            prev_post_crash_high := post_crash_high
else
    // Normal ATH Mode: reset on new ATH
    if ath > prev_ath
        // New ATH reached - reset all used flags
        used_entry_1 := false
        used_entry_2 := false
        used_entry_3 := false
        used_entry_4 := false
        used_entry_5 := false
        used_entry_6 := false
    prev_ath := ath

// ============================================================================
// TRADING LOGIC
// ============================================================================

// Mode filters
can_long = trading_mode == "Long Only" or trading_mode == "Both"
can_short = trading_mode == "Short Only" or trading_mode == "Both"

// Check if enough bars have passed since reference high was set for entry delay
bars_since_ref_high = bar_index - reference_high_bar
delay_met = bars_since_ref_high >= entry_delay

// In Post-Crash Mode: allow entries after min_bars_after_crash OR full stabilization
// In Normal Mode: always allow (no crash gating)
entry_allowed_after_crash = not use_post_crash_mode ? true : (stabilization_complete or (crash_detected and bars_since_crash_low >= min_bars_after_crash))

// Check if we have a valid reference high to trade from AND crash conditions met
has_reference = not na(reference_high) and entry_allowed_after_crash

// Long Entry: Trigger on crossunder through ANY enabled entry level (retraced from reference high)
// Only trigger if: has valid reference, level unused, delay met
long_entry_1 = has_reference and enable_long_entry_1 and not used_entry_1 and delay_met and ta.crossunder(close, long_entry_price_1)
long_entry_2 = has_reference and enable_long_entry_2 and not used_entry_2 and delay_met and ta.crossunder(close, long_entry_price_2)
long_entry_3 = has_reference and enable_long_entry_3 and not used_entry_3 and delay_met and ta.crossunder(close, long_entry_price_3)
long_entry_4 = has_reference and enable_long_entry_4 and not used_entry_4 and delay_met and ta.crossunder(close, long_entry_price_4)
long_entry_5 = has_reference and enable_long_entry_5 and not used_entry_5 and delay_met and ta.crossunder(close, long_entry_price_5)
long_entry_6 = has_reference and enable_long_entry_6 and not used_entry_6 and delay_met and ta.crossunder(close, long_entry_price_6)

long_entry_condition = (long_entry_1 or long_entry_2 or long_entry_3 or long_entry_4 or long_entry_5 or long_entry_6) and can_long

// Store reference high when we enter the position and mark the level as used
if long_entry_condition and strategy.position_size == 0
    entry_ath := reference_high  // Store reference high (ATH in normal mode, post-crash high in post-crash mode)
    // Mark the triggered level as used and track which level for tied exits
    if long_entry_1
        used_entry_1 := true
        entry_level_used := 1
    else if long_entry_2
        used_entry_2 := true
        entry_level_used := 2
    else if long_entry_3
        used_entry_3 := true
        entry_level_used := 3
    else if long_entry_4
        used_entry_4 := true
        entry_level_used := 4
    else if long_entry_5
        used_entry_5 := true
        entry_level_used := 5
    else if long_entry_6
        used_entry_6 := true
        entry_level_used := 6

// Long Exit: TP at stored reference high OR SL at tied exit level
// Exit triggers if: close is below exit level OR open is below exit level (ensures reliable execution)
long_exit_tp = strategy.position_size > 0 and ta.crossover(close, entry_ath)  // TP: Cross back above stored reference high

// Tied stop-loss: Only use the exit level corresponding to the entry level
// Exit if close OR open is below the exit level (not just crossunder)
long_exit_sl = false
if strategy.position_size > 0
    if entry_level_used == 1 and enable_long_exit_1
        long_exit_sl := close <= long_exit_price_1 or open <= long_exit_price_1
    else if entry_level_used == 2 and enable_long_exit_2
        long_exit_sl := close <= long_exit_price_2 or open <= long_exit_price_2
    else if entry_level_used == 3 and enable_long_exit_3
        long_exit_sl := close <= long_exit_price_3 or open <= long_exit_price_3
    else if entry_level_used == 4 and enable_long_exit_4
        long_exit_sl := close <= long_exit_price_4 or open <= long_exit_price_4
    else if entry_level_used == 5 and enable_long_exit_5
        long_exit_sl := close <= long_exit_price_5 or open <= long_exit_price_5
    else if entry_level_used == 6 and enable_long_exit_6
        long_exit_sl := close <= long_exit_price_6 or open <= long_exit_price_6

long_exit_condition = long_exit_tp or long_exit_sl

// Determine which level triggered (for alerts and tracking)
var string entry_trigger = ""
var string exit_trigger = ""

if long_entry_1
    entry_trigger := "Entry 1 (" + str.tostring(long_entry_pct_1, "#.#") + "%)"
else if long_entry_2
    entry_trigger := "Entry 2 (" + str.tostring(long_entry_pct_2, "#.#") + "%)"
else if long_entry_3
    entry_trigger := "Entry 3 (" + str.tostring(long_entry_pct_3, "#.#") + "%)"
else if long_entry_4
    entry_trigger := "Entry 4 (" + str.tostring(long_entry_pct_4, "#.#") + "%)"
else if long_entry_5
    entry_trigger := "Entry 5 (" + str.tostring(long_entry_pct_5, "#.#") + "%)"
else if long_entry_6
    entry_trigger := "Entry 6 (" + str.tostring(long_entry_pct_6, "#.#") + "%)"

if long_exit_tp
    exit_trigger := "Take Profit at ATH: " + str.tostring(entry_ath, "#.####")
else if long_exit_sl
    // Identify which tied exit level triggered
    if entry_level_used == 1
        exit_trigger := "Stop-Loss Exit 1 (" + str.tostring(long_exit_pct_1, "#.#") + "%) - Tied to Entry 1"
    else if entry_level_used == 2
        exit_trigger := "Stop-Loss Exit 2 (" + str.tostring(long_exit_pct_2, "#.#") + "%) - Tied to Entry 2"
    else if entry_level_used == 3
        exit_trigger := "Stop-Loss Exit 3 (" + str.tostring(long_exit_pct_3, "#.#") + "%) - Tied to Entry 3"
    else if entry_level_used == 4
        exit_trigger := "Stop-Loss Exit 4 (" + str.tostring(long_exit_pct_4, "#.#") + "%) - Tied to Entry 4"
    else if entry_level_used == 5
        exit_trigger := "Stop-Loss Exit 5 (" + str.tostring(long_exit_pct_5, "#.#") + "%) - Tied to Entry 5"
    else if entry_level_used == 6
        exit_trigger := "Stop-Loss Exit 6 (" + str.tostring(long_exit_pct_6, "#.#") + "%) - Tied to Entry 6"

// Execute trades
if long_entry_condition and strategy.position_size == 0
    strategy.entry("Long", strategy.long, qty=base_position_size)

if long_exit_condition and strategy.position_size > 0
    strategy.close("Long")
    entry_level_used := 0  // Reset for next trade

// ============================================================================
// VISUALIZATION - RETRACEMENT LEVELS
// ============================================================================

if show_levels and barstate.islast
    // ATH line (reference)
    line.new(bar_index - 200, ath, bar_index + label_offset, ath,
      color=color.new(color.green, 0), width=2, style=line.style_solid)
    label.new(bar_index + label_offset, ath,
      "ATH: " + str.tostring(ath, "#.####"),
      style=label.style_label_left, color=color.new(color.green, 10), textcolor=color.white, size=size.small)

    // ATL or Zero line (reference)
    if range_mode == "ATL to ATH"
        line.new(bar_index - 200, atl, bar_index + label_offset, atl,
          color=color.new(color.red, 0), width=2, style=line.style_solid)
        label.new(bar_index + label_offset, atl,
          "ATL: " + str.tostring(atl, "#.####"),
          style=label.style_label_left, color=color.new(color.red, 10), textcolor=color.white, size=size.small)
    else
        line.new(bar_index - 200, 0, bar_index + label_offset, 0,
          color=color.new(color.red, 0), width=2, style=line.style_solid)
        label.new(bar_index + label_offset, 0,
          "Zero: 0.00",
          style=label.style_label_left, color=color.new(color.red, 10), textcolor=color.white, size=size.small)

    // Long Entry Levels (BLUE - Dashed)
    if enable_long_entry_1
        line.new(bar_index - 200, long_entry_price_1, bar_index + label_offset, long_entry_price_1,
          color=color.new(color.blue, 0), width=2, style=line.style_dashed)
        label.new(bar_index + label_offset, long_entry_price_1,
          "Long Entry 1 (" + str.tostring(long_entry_pct_1, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.blue, 20), textcolor=color.white, size=size.tiny)

    if enable_long_entry_2
        line.new(bar_index - 200, long_entry_price_2, bar_index + label_offset, long_entry_price_2,
          color=color.new(color.blue, 0), width=2, style=line.style_dashed)
        label.new(bar_index + label_offset, long_entry_price_2,
          "Long Entry 2 (" + str.tostring(long_entry_pct_2, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.blue, 20), textcolor=color.white, size=size.tiny)

    if enable_long_entry_3
        line.new(bar_index - 200, long_entry_price_3, bar_index + label_offset, long_entry_price_3,
          color=color.new(color.blue, 0), width=2, style=line.style_dashed)
        label.new(bar_index + label_offset, long_entry_price_3,
          "Long Entry 3 (" + str.tostring(long_entry_pct_3, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.blue, 20), textcolor=color.white, size=size.tiny)

    if enable_long_entry_4
        line.new(bar_index - 200, long_entry_price_4, bar_index + label_offset, long_entry_price_4,
          color=color.new(color.blue, 0), width=2, style=line.style_dashed)
        label.new(bar_index + label_offset, long_entry_price_4,
          "Long Entry 4 (" + str.tostring(long_entry_pct_4, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.blue, 20), textcolor=color.white, size=size.tiny)

    if enable_long_entry_5
        line.new(bar_index - 200, long_entry_price_5, bar_index + label_offset, long_entry_price_5,
          color=color.new(color.blue, 0), width=2, style=line.style_dashed)
        label.new(bar_index + label_offset, long_entry_price_5,
          "Long Entry 5 (" + str.tostring(long_entry_pct_5, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.blue, 20), textcolor=color.white, size=size.tiny)

    if enable_long_entry_6
        line.new(bar_index - 200, long_entry_price_6, bar_index + label_offset, long_entry_price_6,
          color=color.new(color.blue, 0), width=2, style=line.style_dashed)
        label.new(bar_index + label_offset, long_entry_price_6,
          "Long Entry 6 (" + str.tostring(long_entry_pct_6, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.blue, 20), textcolor=color.white, size=size.tiny)

    // Long Exit Levels (LIME - Dotted)
    if enable_long_exit_1
        line.new(bar_index - 200, long_exit_price_1, bar_index + label_offset, long_exit_price_1,
          color=color.new(color.lime, 0), width=2, style=line.style_dotted)
        label.new(bar_index + label_offset, long_exit_price_1,
          "Long Exit 1 (" + str.tostring(long_exit_pct_1, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.lime, 40), textcolor=color.black, size=size.tiny)

    if enable_long_exit_2
        line.new(bar_index - 200, long_exit_price_2, bar_index + label_offset, long_exit_price_2,
          color=color.new(color.lime, 0), width=2, style=line.style_dotted)
        label.new(bar_index + label_offset, long_exit_price_2,
          "Long Exit 2 (" + str.tostring(long_exit_pct_2, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.lime, 40), textcolor=color.black, size=size.tiny)

    if enable_long_exit_3
        line.new(bar_index - 200, long_exit_price_3, bar_index + label_offset, long_exit_price_3,
          color=color.new(color.lime, 0), width=2, style=line.style_dotted)
        label.new(bar_index + label_offset, long_exit_price_3,
          "Long Exit 3 (" + str.tostring(long_exit_pct_3, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.lime, 40), textcolor=color.black, size=size.tiny)

    if enable_long_exit_4
        line.new(bar_index - 200, long_exit_price_4, bar_index + label_offset, long_exit_price_4,
          color=color.new(color.lime, 0), width=2, style=line.style_dotted)
        label.new(bar_index + label_offset, long_exit_price_4,
          "Long Exit 4 (" + str.tostring(long_exit_pct_4, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.lime, 40), textcolor=color.black, size=size.tiny)

    if enable_long_exit_5
        line.new(bar_index - 200, long_exit_price_5, bar_index + label_offset, long_exit_price_5,
          color=color.new(color.lime, 0), width=2, style=line.style_dotted)
        label.new(bar_index + label_offset, long_exit_price_5,
          "Long Exit 5 (" + str.tostring(long_exit_pct_5, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.lime, 40), textcolor=color.black, size=size.tiny)

    if enable_long_exit_6
        line.new(bar_index - 200, long_exit_price_6, bar_index + label_offset, long_exit_price_6,
          color=color.new(color.lime, 0), width=2, style=line.style_dotted)
        label.new(bar_index + label_offset, long_exit_price_6,
          "Long Exit 6 (" + str.tostring(long_exit_pct_6, "#.#") + "%)",
          style=label.style_label_left, color=color.new(color.lime, 40), textcolor=color.black, size=size.tiny)

    // Standard Fibonacci levels (subtle)
    if show_23_6
        line.new(bar_index - 200, level_23_6, bar_index + label_offset, level_23_6,
          color=color.new(color.gray, 60), width=1, style=line.style_dotted)
        label.new(bar_index + label_offset, level_23_6, "23.6%: " + str.tostring(level_23_6, "#.####"),
          style=label.style_label_left, color=color.new(color.gray, 80), textcolor=color.gray, size=size.tiny)

    if show_38_2
        line.new(bar_index - 200, level_38_2, bar_index + label_offset, level_38_2,
          color=color.new(color.gray, 60), width=1, style=line.style_dotted)
        label.new(bar_index + label_offset, level_38_2, "38.2%: " + str.tostring(level_38_2, "#.####"),
          style=label.style_label_left, color=color.new(color.gray, 80), textcolor=color.gray, size=size.tiny)

    if show_50_0
        line.new(bar_index - 200, level_50_0, bar_index + label_offset, level_50_0,
          color=color.new(color.gray, 60), width=1, style=line.style_dotted)
        label.new(bar_index + label_offset, level_50_0, "50.0%: " + str.tostring(level_50_0, "#.####"),
          style=label.style_label_left, color=color.new(color.gray, 80), textcolor=color.gray, size=size.tiny)

    if show_61_8
        line.new(bar_index - 200, level_61_8, bar_index + label_offset, level_61_8,
          color=color.new(color.gray, 60), width=1, style=line.style_dotted)
        label.new(bar_index + label_offset, level_61_8, "61.8%: " + str.tostring(level_61_8, "#.####"),
          style=label.style_label_left, color=color.new(color.gray, 80), textcolor=color.gray, size=size.tiny)

    if show_78_6
        line.new(bar_index - 200, level_78_6, bar_index + label_offset, level_78_6,
          color=color.new(color.gray, 60), width=1, style=line.style_dotted)
        label.new(bar_index + label_offset, level_78_6, "78.6%: " + str.tostring(level_78_6, "#.####"),
          style=label.style_label_left, color=color.new(color.gray, 80), textcolor=color.gray, size=size.tiny)

// ============================================================================
// INFO TABLE
// ============================================================================

if show_info and barstate.islast
    // Count active levels
    entry_count = (enable_long_entry_1 ? 1 : 0) + (enable_long_entry_2 ? 1 : 0) + (enable_long_entry_3 ? 1 : 0) + (enable_long_entry_4 ? 1 : 0) + (enable_long_entry_5 ? 1 : 0) + (enable_long_entry_6 ? 1 : 0)
    exit_count = (enable_long_exit_1 ? 1 : 0) + (enable_long_exit_2 ? 1 : 0) + (enable_long_exit_3 ? 1 : 0) + (enable_long_exit_4 ? 1 : 0) + (enable_long_exit_5 ? 1 : 0) + (enable_long_exit_6 ? 1 : 0)

    // Count available (not used) entry levels
    available_count = ((enable_long_entry_1 and not used_entry_1) ? 1 : 0) + ((enable_long_entry_2 and not used_entry_2) ? 1 : 0) + ((enable_long_entry_3 and not used_entry_3) ? 1 : 0) + ((enable_long_entry_4 and not used_entry_4) ? 1 : 0) + ((enable_long_entry_5 and not used_entry_5) ? 1 : 0) + ((enable_long_entry_6 and not used_entry_6) ? 1 : 0)
    used_count = entry_count - available_count

    // Adjust table size based on mode (Slope detection and Post-Crash mode need more rows)
    table_rows = use_slope_detection ? 23 : (use_post_crash_mode ? 21 : 17)
    var table info = table.new(position.top_right, 2, table_rows, border_width=1)

    table.cell(info, 0, 0, "Retracement Trader MTF", bgcolor=color.new(color.blue, 70), text_color=color.white)
    table.merge_cells(info, 0, 0, 1, 0)

    table.cell(info, 0, 1, "HTF Source", bgcolor=color.new(color.gray, 90))
    table.cell(info, 1, 1, effective_htf, text_color=color.yellow)

    table.cell(info, 0, 2, "Range Mode", bgcolor=color.new(color.gray, 90))
    table.cell(info, 1, 2, range_mode, text_color=color.white)

    table.cell(info, 0, 3, "Trading Mode", bgcolor=color.new(color.gray, 90))
    mode_color = trading_mode == "Long Only" ? color.green : trading_mode == "Short Only" ? color.red : color.blue
    table.cell(info, 1, 3, trading_mode, text_color=mode_color)

    table.cell(info, 0, 4, "Mode", bgcolor=color.new(color.gray, 90))
    ref_mode = use_post_crash_mode ? "Post-Crash" : "ATH"
    table.cell(info, 1, 4, ref_mode, text_color=use_post_crash_mode ? color.orange : color.green)

    table.cell(info, 0, 5, "Entry Delay", bgcolor=color.new(color.gray, 90))
    delay_status = entry_delay == 0 ? "Disabled" : (delay_met ? str.tostring(bars_since_ref_high) + "/" + str.tostring(entry_delay) + " ✓" : str.tostring(bars_since_ref_high) + "/" + str.tostring(entry_delay))
    delay_color = entry_delay == 0 ? color.gray : (delay_met ? color.green : color.orange)
    table.cell(info, 1, 5, delay_status, text_color=delay_color)

    // Slope Detection status (if enabled)
    current_row = 6
    if use_slope_detection
        table.cell(info, 0, 6, "Slope Detection", bgcolor=color.new(color.gray, 70), text_color=color.white)
        table.merge_cells(info, 0, 6, 1, 6)

        table.cell(info, 0, 7, "Method", bgcolor=color.new(color.gray, 90))
        table.cell(info, 1, 7, slope_method, text_color=color.purple)

        table.cell(info, 0, 8, "Period", bgcolor=color.new(color.gray, 90))
        table.cell(info, 1, 8, str.tostring(slope_period), text_color=color.white)

        table.cell(info, 0, 9, "Current Slope", bgcolor=color.new(color.gray, 90))
        slope_direction = slope_sign == 1 ? "↑ Up" : (slope_sign == -1 ? "↓ Down" : "→ Flat")
        slope_color = slope_sign == 1 ? color.green : (slope_sign == -1 ? color.red : color.gray)
        table.cell(info, 1, 9, slope_direction, text_color=slope_color)

        table.cell(info, 0, 10, "Ref Source", bgcolor=color.new(color.gray, 90))
        table.cell(info, 1, 10, reference_source, text_color=color.yellow)

        current_row := 11

    // Post-Crash Mode status (if enabled)
    drop_status = ""
    drop_color = color.gray
    if use_post_crash_mode
        table.cell(info, 0, current_row, "Post-Crash Status", bgcolor=color.new(color.gray, 70), text_color=color.white)
        table.merge_cells(info, 0, current_row, 1, current_row)

        table.cell(info, 0, current_row + 1, "Crash Detected", bgcolor=color.new(color.gray, 90))
        if use_zscore
            drop_status := crash_detected ? "Yes (z=" + str.tostring(current_zscore, "#.##") + ")" : "No (z=" + str.tostring(current_zscore, "#.##") + ")"
        else
            drop_status := crash_detected ? "Yes (" + str.tostring(current_drop_pct, "#.#") + "%)" : "No (" + str.tostring(current_drop_pct, "#.#") + "%)"
        drop_color := crash_detected ? color.orange : color.gray
        table.cell(info, 1, current_row + 1, drop_status, text_color=drop_color)

        table.cell(info, 0, current_row + 2, "Stabilization", bgcolor=color.new(color.gray, 90))
        stab_status = not crash_detected ? "Waiting for crash" : (stabilization_complete ? str.tostring(bars_since_crash_low) + "/" + str.tostring(stabilization_bars) + " ✓" : str.tostring(bars_since_crash_low) + "/" + str.tostring(stabilization_bars))
        stab_color = stabilization_complete ? color.green : color.orange
        table.cell(info, 1, current_row + 2, stab_status, text_color=stab_color)

        table.cell(info, 0, current_row + 3, "Ref High", bgcolor=color.new(color.gray, 90))
        ref_high_display = na(post_crash_high) ? "Waiting..." : str.tostring(post_crash_high, "#.####")
        table.cell(info, 1, current_row + 3, ref_high_display, text_color=na(post_crash_high) ? color.gray : color.yellow)

        current_row := current_row + 4

    table.cell(info, 0, current_row, "Range", bgcolor=color.new(color.gray, 70), text_color=color.white)
    table.merge_cells(info, 0, current_row, 1, current_row)

    table.cell(info, 0, current_row + 1, "ATH", bgcolor=color.new(color.gray, 90))
    table.cell(info, 1, current_row + 1, str.tostring(ath, "#.####"), text_color=color.green)

    table.cell(info, 0, current_row + 2, "ATL/Zero", bgcolor=color.new(color.gray, 90))
    table.cell(info, 1, current_row + 2, str.tostring(range_low, "#.####"), text_color=color.red)

    table.cell(info, 0, current_row + 3, "Range Size", bgcolor=color.new(color.gray, 90))
    table.cell(info, 1, current_row + 3, str.tostring(range_size, "#.####"), text_color=color.white)

    table.cell(info, 0, current_row + 4, "Active Levels", bgcolor=color.new(color.gray, 70), text_color=color.white)
    table.merge_cells(info, 0, current_row + 4, 1, current_row + 4)

    table.cell(info, 0, current_row + 5, "Entry Levels", bgcolor=color.new(color.gray, 90))
    table.cell(info, 1, current_row + 5, str.tostring(entry_count) + " active", text_color=color.blue)

    table.cell(info, 0, current_row + 6, "Available/Used", bgcolor=color.new(color.gray, 90))
    table.cell(info, 1, current_row + 6, str.tostring(available_count) + "/" + str.tostring(used_count), text_color=available_count > 0 ? color.green : color.orange)

    table.cell(info, 0, current_row + 7, "Exit Levels", bgcolor=color.new(color.gray, 90))
    table.cell(info, 1, current_row + 7, str.tostring(exit_count) + " active", text_color=color.lime)

    table.cell(info, 0, current_row + 8, "Status", bgcolor=color.new(color.gray, 70), text_color=color.white)
    table.merge_cells(info, 0, current_row + 8, 1, current_row + 8)

    table.cell(info, 0, current_row + 9, "Current Price", bgcolor=color.new(color.gray, 90))
    price_pct = range_size > 0 ? (close - range_low) / range_size * 100 : 0
    table.cell(info, 1, current_row + 9, str.tostring(close, "#.####") + " (" + str.tostring(price_pct, "#.#") + "%)", text_color=color.yellow)

    table.cell(info, 0, current_row + 10, "Net P&L", bgcolor=color.new(color.gray, 90))
    pnl_color = strategy.netprofit > 0 ? color.green : color.red
    table.cell(info, 1, current_row + 10, str.tostring(strategy.netprofit, "#,###"), text_color=pnl_color)

// ============================================================================
// ALERTS
// ============================================================================

if long_entry_condition
    alert("Retracement: Long Entry at " + str.tostring(close, "#.####") + " | Triggered by " + entry_trigger, alert.freq_once_per_bar_close)

if long_exit_condition
    alert("Retracement: Long Exit at " + str.tostring(close, "#.####") + " | Triggered by " + exit_trigger, alert.freq_once_per_bar_close)

// ============================================================================
// VISUAL DEBUG MARKERS (Slope Detection Mode)
// ============================================================================

if use_slope_detection
    // Mark when slope changes to negative (local high detected)
    if slope_change_to_negative
        label.new(bar_index, high,
          "LOCAL HIGH\n" + slope_method + "\n" + str.tostring(slope_detected_high, "#.####"),
          style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white, size=size.small)

    // Mark when slope changes to positive (local low detected)
    if slope_change_to_positive
        label.new(bar_index, low,
          "LOCAL LOW\n" + slope_method + "\n" + str.tostring(slope_detected_low, "#.####"),
          style=label.style_label_up, color=color.new(color.green, 20), textcolor=color.white, size=size.small)

    // Show slope-detected high line on the chart
    if not na(slope_detected_high) and barstate.islast
        line.new(bar_index - 50, slope_detected_high, bar_index + label_offset, slope_detected_high,
          color=color.new(color.purple, 30), width=3, style=line.style_solid)
        label.new(bar_index + label_offset, slope_detected_high,
          "Slope High: " + str.tostring(slope_detected_high, "#.####"),
          style=label.style_label_left, color=color.new(color.purple, 20), textcolor=color.white, size=size.normal)

// Plot slope for debugging (when slope detection enabled)
plot(use_slope_detection ? normalized_slope * 10000 : na, title="Normalized Slope (x10000)", color=color.new(color.blue, 0), linewidth=1)
hline(0, title="Zero Slope", color=color.new(color.gray, 70), linestyle=hline.style_dotted)

// ============================================================================
// VISUAL DEBUG MARKERS (Post-Crash Mode)
// ============================================================================

if use_post_crash_mode
    // Mark when stabilization completes
    var bool stabilization_marked = false
    if stabilization_complete and not stabilization_marked and barstate.islast
        label.new(bar_index, htf_low,
          "Stabilization Complete",
          style=label.style_label_up, color=color.new(color.orange, 30), textcolor=color.white, size=size.tiny,
          yloc=yloc.belowbar)
        stabilization_marked := true

    // Mark post-crash high when it's set
    if not na(post_crash_high) and barstate.islast
        line.new(bar_index - 50, post_crash_high, bar_index, post_crash_high,
          color=color.new(color.orange, 50), width=2, style=line.style_dashed)
        label.new(bar_index, post_crash_high,
          "Post-Crash High: " + str.tostring(post_crash_high, "#.####"),
          style=label.style_label_left, color=color.new(color.orange, 30), textcolor=color.white, size=size.small)

// Plot z-score for debugging (when post-crash mode enabled)
plot(use_post_crash_mode ? current_zscore : na, title="Z-Score", color=color.new(color.purple, 0), linewidth=2)
hline(use_post_crash_mode ? zscore_threshold : na, title="Z-Score Threshold", color=color.new(color.red, 50), linestyle=hline.style_dashed)

// ============================================================================
// END - RETRACEMENT TRADER MTF
// ============================================================================
